<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><strike>BEST</strike> okay ece quiz game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex items-center justify-center h-screen">
  <div id="sketch-holder" class="w-full max-w-2xl"></div>
  <input type="file" id="fileInput" accept=".txt,.pdf,.docx" class="mt-4 p-2 border rounded" style="display: none;">
  <script>
    let state = 'start';
    let questions = [];
    let currentQuestion = 0;
    let score = 0;
    let questionNumber = 1;
    let progress = 0;
    let isUploading = false;
    let loadingTimeout;
    let answerFeedback = null;
    let feedbackTimer = null;
    let selectedCategory = null; // New variable to store selected category
    const API_URL = 'https://testtaker-f33a.onrender.com';
    const CATEGORIES = ['ELECTRONICS', 'ESAT', 'GEAS', 'MATHEMATICS'];

    function setup() {
      let canvas = createCanvas(600, 700);
      canvas.parent('sketch-holder');
      loadProgress();
      fetchQuestions(); // Fetch all questions initially to get a count or for general play
      noLoop();
    }

    function draw() {
      background(255);
      textFont('Arial');
      if (state === 'start') {
        drawStartScreen();
      } else if (state === 'quiz') {
        drawQuizScreen();
      } else if (state === 'upload') {
        drawUploadScreen();
      } else if (state === 'categories') {
        drawCategoriesScreen();
      }
      if (answerFeedback) {
        drawFeedback();
      }
    }

    function drawStartScreen() {
      textAlign(CENTER, CENTER);
      textSize(32);
      fill(0);
      text('<strike>BEST</strike> okay ece quiz game', width / 2, height / 4);

      fill(100, 200, 100);
      rect(width / 2 - 100, height / 2 - 100, 200, 50, 10);
      fill(255);
      textSize(20);
      text('Play All Questions', width / 2, height / 2 - 75);

      fill(100, 100, 200);
      rect(width / 2 - 100, height / 2 - 30, 200, 50, 10);
      fill(255);
      text('Categories', width / 2, height / 2 - 5);

      fill(255, 165, 0);
      rect(width / 2 - 100, height / 2 + 40, 200, 50, 10);
      fill(255);
      text('Upload Questions', width / 2, height / 2 + 65);

      fill(200, 100, 100);
      rect(width / 2 - 100, height / 2 + 110, 200, 50, 10);
      fill(255);
      text('Reset Quiz', width / 2, height / 2 + 135);

      fill(150, 150, 150);
      rect(width / 2 - 100, height / 2 + 180, 200, 50, 10);
      fill(255);
      text('Clear All Questions', width / 2, height / 2 + 205);
    }

    function drawQuizScreen() {
      if (questions.length === 0) {
        textAlign(CENTER, CENTER);
        textSize(20);
        fill(0);
        text('Loading questions...', width / 2, height / 2);
        return;
      }
      let q = questions[currentQuestion];

      textSize(18);
      textAlign(RIGHT, TOP);
      fill(0);
      text(`Score: ${score} | Question: ${questionNumber}`, width - 40, 40);

      textSize(18);
      textAlign(LEFT, TOP);
      fill(0);
      text(`Category: ${selectedCategory || 'All'}`, 40, 40);

      let questionBoxWidth = 400;
      let questionBoxX = (width - questionBoxWidth) / 2;
      textSize(22);
      textAlign(LEFT, TOP);
      fill(0);
      text(q.question, questionBoxX, 100, questionBoxWidth, 120);

      let buttonWidth = 400;
      let buttonHeight = 50;
      let buttonX = (width - buttonWidth) / 2;
      let firstButtonY = 250;
      let buttonSpacing = 20;

      for (let i = 0; i < q.options.length; i++) {
        let y = firstButtonY + i * (buttonHeight + buttonSpacing);
        if (answerFeedback && answerFeedback.selected === i) {
          fill(answerFeedback.correct ? 0 : 255, answerFeedback.correct ? 255 : 0, 0);
        } else {
          fill(200);
        }
        rect(buttonX, y, buttonWidth, buttonHeight, 12);
        fill(0);
        textSize(18);
        textAlign(CENTER, CENTER);
        text(q.options[i], buttonX + buttonWidth / 2, y + buttonHeight / 2);
      }

      fill(100, 100, 200);
      rect(width / 2 - 100, 600, 200, 50, 10);
      fill(255);
      textSize(20);
      textAlign(CENTER, CENTER);
      text('Back to Menu', width / 2, 625);
    }

    function drawUploadScreen() {
      textSize(18);
      textAlign(CENTER, TOP);
      fill(0);
      text('Upload a .txt, .pdf, or .docx file', width / 2, height / 4);
      textSize(16);
      text('Select Category for Upload:', width / 2, height / 4 + 40);

      // Category selection for upload
      let categoryButtonsY = height / 4 + 70;
      let catButtonWidth = 120;
      let catButtonHeight = 30;
      let catButtonSpacing = 10;
      for (let i = 0; i < CATEGORIES.length; i++) {
        let categoryName = CATEGORIES[i];
        let x = width / 2 - (CATEGORIES.length / 2) * (catButtonWidth + catButtonSpacing) + i * (catButtonWidth + catButtonSpacing);
        fill(selectedCategory === categoryName ? 150 : 200);
        rect(x, categoryButtonsY, catButtonWidth, catButtonHeight, 5);
        fill(0);
        textSize(14);
        text(categoryName, x + catButtonWidth / 2, categoryButtonsY + catButtonHeight / 2);
      }

      if (isUploading) {
        fill(200);
        rect(width / 2 - 100, height / 2 + 100, 200, 30);
        fill(100, 200, 100);
        rect(width / 2 - 100, height / 2 + 100, (progress / 100) * 200, 30);
      } else {
        fill(100, 100, 200);
        rect(width / 2 - 100, height / 2 + 100, 200, 50, 10);
        fill(255);
        textSize(18);
        text('Select File & Upload', width / 2, height / 2 + 125);

        fill(200, 100, 100);
        rect(width / 2 - 100, height / 2 + 170, 200, 50, 10);
        fill(255);
        text('Back to Menu', width / 2, height / 2 + 195);
      }
    }

    function drawCategoriesScreen() {
      textAlign(CENTER, CENTER);
      textSize(32);
      fill(0);
      text('Select a Category', width / 2, height / 4);

      let buttonWidth = 250;
      let buttonHeight = 60;
      let buttonX = (width - buttonWidth) / 2;
      let firstButtonY = height / 2 - 100;
      let buttonSpacing = 20;

      for (let i = 0; i < CATEGORIES.length; i++) {
        let y = firstButtonY + i * (buttonHeight + buttonSpacing);
        fill(100, 200, 100);
        rect(buttonX, y, buttonWidth, buttonHeight, 10);
        fill(255);
        textSize(20);
        text(CATEGORIES[i], width / 2, y + buttonHeight / 2);
      }

      fill(200, 100, 100);
      rect(width / 2 - 100, firstButtonY + CATEGORIES.length * (buttonHeight + buttonSpacing), 200, 50, 10);
      fill(255);
      textSize(20);
      text('Back to Menu', width / 2, firstButtonY + CATEGORIES.length * (buttonHeight + buttonSpacing) + 25);
    }

    function drawFeedback() {
      if (answerFeedback) {
        fill(255, 255, 255, 200);
        rect(0, 0, width, height);
        textSize(20);
        fill(0);
        textAlign(CENTER, CENTER);
        text('Answer Feedback', width / 2, height / 2 - 60);
        text(answerFeedback.correct ? 'Correct!' : 'Wrong!', width / 2, height / 2 - 20);
        if (!answerFeedback.correct) {
          textSize(16);
          textAlign(CENTER, TOP);
          text(`Correct answer: ${answerFeedback.correctAnswer}`, width / 2, height / 2 + 20);
        }
      }
    }

    function mousePressed() {
      if (state === 'start') {
        if (mouseX > width / 2 - 100 && mouseX < width / 2 + 100) {
          if (mouseY > height / 2 - 100 && mouseY < height / 2 - 50) { // Play All Questions
            state = 'quiz';
            selectedCategory = null;
            currentQuestion = 0;
            score = 0;
            questionNumber = 1;
            answerFeedback = null;
            saveProgress();
            fetchQuestions(); // Fetch all questions
          } else if (mouseY > height / 2 - 30 && mouseY < height / 2 + 20) { // Categories
            state = 'categories';
          } else if (mouseY > height / 2 + 40 && mouseY < height / 2 + 90) { // Upload Questions
            state = 'upload';
            selectedCategory = null; // Reset category selection for upload
          } else if (mouseY > height / 2 + 110 && mouseY < height / 2 + 160) { // Reset Quiz
            resetQuiz();
          } else if (mouseY > height / 2 + 180 && mouseY < height / 2 + 230) { // Clear All Questions
            clearQuestions(null); // Clear all questions
          }
        }
      } else if (state === 'quiz') {
        let buttonWidth = 400;
        let buttonHeight = 50;
        let buttonX = (width - buttonWidth) / 2;
        let firstButtonY = 250;
        let buttonSpacing = 20;
        for (let i = 0; i < questions[currentQuestion].options.length; i++) {
          let y = firstButtonY + i * (buttonHeight + buttonSpacing);
          if (mouseX > buttonX && mouseX < buttonX + buttonWidth && mouseY > y && mouseY < y + buttonHeight) {
            checkAnswer(i);
            return;
          }
        }
        if (mouseX > width / 2 - 100 && mouseX < width / 2 + 100 && mouseY > 600 && mouseY < 650) { // Back to Menu
          state = 'start';
          redraw();
        }
      } else if (state === 'upload' && !isUploading) {
        let categoryButtonsY = height / 4 + 70;
        let catButtonWidth = 120;
        let catButtonHeight = 30;
        let catButtonSpacing = 10;
        // Check for category selection
        for (let i = 0; i < CATEGORIES.length; i++) {
          let categoryName = CATEGORIES[i];
          let x = width / 2 - (CATEGORIES.length / 2) * (catButtonWidth + catButtonSpacing) + i * (catButtonWidth + catButtonSpacing);
          if (mouseX > x && mouseX < x + catButtonWidth && mouseY > categoryButtonsY && mouseY < categoryButtonsY + catButtonHeight) {
            selectedCategory = categoryName;
            redraw();
            return;
          }
        }

        if (mouseX > width / 2 - 100 && mouseX < width / 2 + 100 && mouseY > height / 2 + 100 && mouseY < height / 2 + 150) { // Select File & Upload
          document.getElementById('fileInput').click();
        } else if (mouseX > width / 2 - 100 && mouseX < width / 2 + 100 && mouseY > height / 2 + 170 && mouseY < height / 2 + 220) { // Back to Menu
          state = 'start';
          redraw();
        }
      } else if (state === 'categories') {
        let buttonWidth = 250;
        let buttonHeight = 60;
        let buttonX = (width - buttonWidth) / 2;
        let firstButtonY = height / 2 - 100;
        let buttonSpacing = 20;

        for (let i = 0; i < CATEGORIES.length; i++) {
          let y = firstButtonY + i * (buttonHeight + buttonSpacing);
          if (mouseX > buttonX && mouseX < buttonX + buttonWidth && mouseY > y && mouseY < y + buttonHeight) {
            selectedCategory = CATEGORIES[i];
            state = 'quiz';
            currentQuestion = 0;
            score = 0;
            questionNumber = 1;
            answerFeedback = null;
            saveProgress();
            fetchQuestions(selectedCategory);
            return;
          }
        }
        let backButtonY = firstButtonY + CATEGORIES.length * (buttonHeight + buttonSpacing);
        if (mouseX > width / 2 - 100 && mouseX < width / 2 + 100 && mouseY > backButtonY && mouseY < backButtonY + 50) { // Back to Menu
          state = 'start';
          redraw();
        }
      }
    }

    function checkAnswer(selected) {
      let q = questions[currentQuestion];
      let correctIndex = 'abcd'.indexOf(q.answer.toLowerCase());
      let correct = selected === correctIndex;
      answerFeedback = {
        selected,
        correct,
        correctAnswer: correctIndex >= 0 ? q.options[correctIndex] : 'Unknown'
      };
      if (correct) score++;
      questionNumber++;
      saveProgress();

      if (feedbackTimer) clearTimeout(feedbackTimer);
      feedbackTimer = setTimeout(() => {
        answerFeedback = null;
        currentQuestion = (currentQuestion + 1) % questions.length;
        redraw();
      }, 2000);
      redraw();
    }

    function saveProgress() {
      localStorage.setItem('quizScore', score);
      localStorage.setItem('questionNumber', questionNumber);
      localStorage.setItem('selectedCategory', selectedCategory);
    }

    function loadProgress() {
      score = parseInt(localStorage.getItem('quizScore')) || 0;
      questionNumber = parseInt(localStorage.getItem('questionNumber')) || 1;
      selectedCategory = localStorage.getItem('selectedCategory');
    }

    function fetchQuestions(category = null) {
      clearTimeout(loadingTimeout);
      questions = [];
      progress = 0;

      loadingTimeout = setTimeout(() => {
        if (questions.length === 0) {
          questions = [];
          alert('Failed to load questions after timeout. Please try again.');
        }
      }, 10000);

      let url = `${API_URL}/api/questions`;
      if (category) {
        url += `?category=${category}`;
      }

      fetch(url, { timeout: 10000 })
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok: ' + response.statusText);
          }
          return response.json();
        })
        .then(data => {
          questions = data;
          progress = 100;
          isUploading = false;
          clearTimeout(loadingTimeout);
          redraw();
        })
        .catch(error => {
          console.error('Error fetching questions:', error.message);
          questions = [];
          progress = 0;
          isUploading = false;
          clearTimeout(loadingTimeout);
          alert('Error fetching questions: ' + error.message);
        });
    }

    async function resetQuiz() {
      try {
        const response = await fetch(`${API_URL}/api/reset`, { method: 'POST' });
        if (!response.ok) {
          throw new Error('Network response was not ok: ' + await response.text());
        }
        const result = await response.json();
        score = 0;
        questionNumber = 1;
        currentQuestion = 0;
        answerFeedback = null;
        saveProgress();
        fetchQuestions(selectedCategory); // Refetch based on current category
        alert(result.message);
      } catch (error) {
        console.error('Error resetting quiz:', error.message);
        alert('Error resetting quiz: ' + error.message);
      }
    }

    async function clearQuestions(category = null) {
      let confirmationMessage = 'Are you sure you want to delete all questions? This cannot be undone.';
      let requestBody = { confirm: 'DELETE' };

      if (category) {
        confirmationMessage = `Are you sure you want to delete all questions for category "${category}"? This cannot be undone.`;
        requestBody.category = category;
      }

      if (!confirm(confirmationMessage)) {
        return;
      }
      try {
        const response = await fetch(`${API_URL}/api/clear`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        if (!response.ok) {
          throw new Error('Network response was not ok: ' + await response.text());
        }
        const result = await response.json();
        score = 0;
        questionNumber = 1;
        currentQuestion = 0;
        answerFeedback = null;
        saveProgress();
        fetchQuestions(selectedCategory); // Refetch based on current category
        alert(result.message);
      } catch (error) {
        console.error('Error clearing questions:', error.message);
        alert('Error clearing questions: ' + error.message);
      }
    }

    document.getElementById('fileInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      if (!selectedCategory) {
        alert('Please select a category for the uploaded questions.');
        return;
      }

      const formData = new FormData();
      formData.append('file', file);
      formData.append('category', selectedCategory); // Append category to form data

      isUploading = true;
      progress = 0;
      redraw(); // Update UI to show progress bar

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);

      fetch(`${API_URL}/api/upload`, {
        method: 'POST',
        body: formData,
        signal: controller.signal
      })
        .then(response => {
          clearTimeout(timeoutId);
          if (!response.ok) {
            return response.text().then(text => {
              throw new Error(`Network response was not ok: ${response.status} - ${text}`);
            });
          }
          return response.json();
        })
        .then(data => {
          progress = 100;
          isUploading = false;
          fetchQuestions(selectedCategory); // Refetch questions for the selected category after upload
          alert(`Upload successful! Added ${data.questionsAdded} questions to ${data.category} category.`);
          redraw();
        })
        .catch(error => {
          console.error('Upload error:', error.message);
          progress = 0;
          isUploading = false;
          clearTimeout(timeoutId);
          alert('Error during upload: ' + error.message);
          redraw();
        });
    });
  </script>
</body>
</html>