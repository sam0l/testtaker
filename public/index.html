<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quiz Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex items-center justify-center h-screen">
  <div id="sketch-holder" class="w-full max-w-2xl"></div>
  <input type="file" id="fileInput" accept=".txt,.pdf,.docx" class="mt-4 p-2 border rounded" style="display: none;">
  <script>
    let state = 'start';
    let questions = [];
    let currentQuestion = 0;
    let score = 0;
    let questionNumber = 1;
    let progress = 0;
    let isUploading = false;
    let loadingTimeout;
    let answerFeedback = null;
    let feedbackTimer = null;
    const API_URL = 'http://127.0.0.1:3000';

    function setup() {
      let canvas = createCanvas(600, 700);
      canvas.parent('sketch-holder');
      loadProgress();
      fetchQuestions();
      noLoop();
    }

    function draw() {
      background(255);
      textFont('Arial');
      if (state === 'start') {
        drawStartScreen();
      } else if (state === 'quiz') {
        drawQuizScreen();
      } else if (state === 'upload') {
        drawUploadScreen();
      }
      if (answerFeedback) {
        drawFeedback();
      }
    }

    function drawStartScreen() {
      textAlign(CENTER, CENTER);
      textSize(32);
      fill(0);
      text('Welcome to the Quiz Game!', width / 2, height / 4);

      fill(100, 200, 100);
      rect(width / 2 - 100, height / 2 - 100, 200, 50, 10);
      fill(255);
      textSize(20);
      text('Play', width / 2, height / 2 - 75);

      fill(100, 100, 200);
      rect(width / 2 - 100, height / 2 - 30, 200, 50, 10);
      fill(255);
      text('Upload Questions', width / 2, height / 2 - 5);

      fill(255, 165, 0);
      rect(width / 2 - 100, height / 2 + 40, 200, 50, 10);
      fill(255);
      text('Reset Quiz', width / 2, height / 2 + 65);

      fill(200, 100, 100);
      rect(width / 2 - 100, height / 2 + 110, 200, 50, 10);
      fill(255);
      text('Clear Questions', width / 2, height / 2 + 135);
    }

    function drawQuizScreen() {
      if (questions.length === 0) {
        textAlign(CENTER, CENTER);
        textSize(20);
        fill(0);
        text('Loading questions...', width / 2, height / 2);
        return;
      }
      let q = questions[currentQuestion];

      textSize(18);
      textAlign(RIGHT, TOP);
      fill(0);
      text(`Score: ${score} | Question: ${questionNumber}`, width - 40, 40);

      let questionBoxWidth = 400;
      let questionBoxX = (width - questionBoxWidth) / 2;
      textSize(22);
      textAlign(LEFT, TOP);
      fill(0);
      text(q.question, questionBoxX, 100, questionBoxWidth, 120);

      let buttonWidth = 400;
      let buttonHeight = 50;
      let buttonX = (width - buttonWidth) / 2;
      let firstButtonY = 250;
      let buttonSpacing = 20;

      for (let i = 0; i < q.options.length; i++) {
        let y = firstButtonY + i * (buttonHeight + buttonSpacing);
        if (answerFeedback && answerFeedback.selected === i) {
          fill(answerFeedback.correct ? 0 : 255, answerFeedback.correct ? 255 : 0, 0);
        } else {
          fill(200);
        }
        rect(buttonX, y, buttonWidth, buttonHeight, 12);
        fill(0);
        textSize(18);
        textAlign(CENTER, CENTER);
        text(q.options[i], buttonX + buttonWidth / 2, y + buttonHeight / 2);
      }

      fill(100, 100, 200);
      rect(width / 2 - 100, 600, 200, 50, 10);
      fill(255);
      textSize(20);
      textAlign(CENTER, CENTER);
      text('Upload Questions', width / 2, 625);

      fill(255, 165, 0);
      rect(width / 2 - 300, 600, 150, 50, 10);
      fill(255);
      text('Reset Quiz', width / 2 - 225, 625);

      fill(200, 100, 100);
      rect(width / 2 + 150, 600, 150, 50, 10);
      fill(255);
      text('Clear Questions', width / 2 + 225, 625);
    }

    function drawUploadScreen() {
      textSize(18);
      textAlign(CENTER, TOP);
      fill(0);
      text('Upload a .txt, .pdf, or .docx file', width / 2, height / 4, width - 40);
      if (isUploading) {
        fill(200);
        rect(width / 2 - 100, height / 2 - 40, 200, 30);
        fill(100, 200, 100);
        rect(width / 2 - 100, height / 2 - 40, (progress / 100) * 200, 30);
      } else {
        fill(100, 100, 200);
        rect(width / 2 - 100, height / 2 - 40, 200, 50, 10);
        fill(255);
        textSize(18);
        text('Upload', width / 2, height / 2 - 15);

        fill(200, 100, 100);
        rect(width / 2 - 100, height / 2 + 20, 200, 50, 10);
        fill(255);
        text('Back', width / 2, height / 2 + 45);
      }
    }

    function drawFeedback() {
      if (answerFeedback) {
        fill(255, 255, 255, 200);
        rect(0, 0, width, height);
        textSize(20);
        fill(0);
        textAlign(CENTER, CENTER);
        text('Answer Feedback', width / 2, height / 2 - 40);
        text(answerFeedback.correct ? 'Correct!' : 'Wrong!', width / 2, height / 2);
        if (!answerFeedback.correct) {
          textSize(16);
          text(`Correct answer: ${answerFeedback.correctAnswer}`, width / 2, height / 2 + 40, width - 40);
        }
      }
    }

    function mousePressed() {
      if (state === 'start') {
        if (mouseX > width / 2 - 100 && mouseX < width / 2 + 100) {
          if (mouseY > height / 2 - 100 && mouseY < height / 2 - 50) {
            state = 'quiz';
            currentQuestion = 0;
            score = 0;
            questionNumber = 1;
            answerFeedback = null;
            saveProgress();
            redraw();
          } else if (mouseY > height / 2 - 30 && mouseY < height / 2 + 20) {
            state = 'upload';
            redraw();
          } else if (mouseY > height / 2 + 40 && mouseY < height / 2 + 90) {
            resetQuiz();
          } else if (mouseY > height / 2 + 110 && mouseY < height / 2 + 160) {
            clearQuestions();
          }
        }
      } else if (state === 'quiz') {
        let buttonWidth = 400;
        let buttonHeight = 50;
        let buttonX = (width - buttonWidth) / 2;
        let firstButtonY = 250;
        let buttonSpacing = 20;
        for (let i = 0; i < questions[currentQuestion].options.length; i++) {
          let y = firstButtonY + i * (buttonHeight + buttonSpacing);
          if (mouseX > buttonX && mouseX < buttonX + buttonWidth && mouseY > y && mouseY < y + buttonHeight) {
            checkAnswer(i);
            return;
          }
        }
        if (mouseX > width / 2 - 100 && mouseX < width / 2 + 100 && mouseY > 600 && mouseY < 650) {
          state = 'upload';
          redraw();
        } else if (mouseX > width / 2 - 300 && mouseX < width / 2 - 150 && mouseY > 600 && mouseY < 650) {
          resetQuiz();
        } else if (mouseX > width / 2 + 150 && mouseX < width / 2 + 300 && mouseY > 600 && mouseY < 650) {
          clearQuestions();
        }
      } else if (state === 'upload' && !isUploading) {
        if (mouseX > width / 2 - 100 && mouseX < width / 2 + 100 && mouseY > height / 2 - 40 && mouseY < height / 2 + 10) {
          document.getElementById('fileInput').click();
        } else if (mouseX > width / 2 - 100 && mouseX < width / 2 + 100 && mouseY > height / 2 + 20 && mouseY < height / 2 + 70) {
          state = 'quiz';
          fetchQuestions();
          redraw();
        }
      }
    }

    function checkAnswer(selected) {
      let q = questions[currentQuestion];
      let correctIndex = 'abcd'.indexOf(q.answer.toLowerCase());
      let correct = selected === correctIndex;
      answerFeedback = {
        selected,
        correct,
        correctAnswer: correctIndex >= 0 ? q.options[correctIndex] : 'Unknown'
      };
      if (correct) score++;
      questionNumber++;
      saveProgress();

      if (feedbackTimer) clearTimeout(feedbackTimer);
      feedbackTimer = setTimeout(() => {
        answerFeedback = null;
        currentQuestion = (currentQuestion + 1) % questions.length;
        redraw();
      }, 2000); // Increased to 2 seconds for readability
      redraw();
    }

    function saveProgress() {
      localStorage.setItem('quizScore', score);
      localStorage.setItem('questionNumber', questionNumber);
    }

    function loadProgress() {
      score = parseInt(localStorage.getItem('quizScore')) || 0;
      questionNumber = parseInt(localStorage.getItem('questionNumber')) || 1;
    }

    function fetchQuestions() {
      clearTimeout(loadingTimeout);
      questions = [];
      progress = 0;

      loadingTimeout = setTimeout(() => {
        if (questions.length === 0) {
          questions = [];
          alert('Failed to load questions after timeout. Please try again.');
        }
      }, 10000);

      fetch(`${API_URL}/api/questions`, { timeout: 10000 })
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok: ' + response.statusText);
          }
          return response.json();
        })
        .then(data => {
          questions = data;
          progress = 100;
          isUploading = false;
          clearTimeout(loadingTimeout);
          redraw();
        })
        .catch(error => {
          console.error('Error fetching questions:', error.message);
          questions = [];
          progress = 0;
          isUploading = false;
          clearTimeout(loadingTimeout);
          alert('Error fetching questions: ' + error.message);
        });
    }

    async function resetQuiz() {
      try {
        const response = await fetch(`${API_URL}/api/reset`, { method: 'POST' });
        if (!response.ok) {
          throw new Error('Network response was not ok: ' + await response.text());
        }
        const result = await response.json();
        score = 0;
        questionNumber = 1;
        currentQuestion = 0;
        answerFeedback = null;
        saveProgress();
        fetchQuestions();
        alert(result.message);
      } catch (error) {
        console.error('Error resetting quiz:', error.message);
        alert('Error resetting quiz: ' + error.message);
      }
    }

    async function clearQuestions() {
      if (!confirm('Are you sure you want to delete all questions? This cannot be undone.')) {
        return;
      }
      try {
        const response = await fetch(`${API_URL}/api/clear`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ confirm: 'DELETE' })
        });
        if (!response.ok) {
          throw new Error('Network response was not ok: ' + await response.text());
        }
        const result = await response.json();
        score = 0;
        questionNumber = 1;
        currentQuestion = 0;
        answerFeedback = null;
        saveProgress();
        fetchQuestions();
        alert(result.message);
      } catch (error) {
        console.error('Error clearing questions:', error.message);
        alert('Error clearing questions: ' + error.message);
      }
    }

    document.getElementById('fileInput').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const formData = new FormData();
      formData.append('file', file);

      isUploading = true;
      progress = 0;

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);

      fetch(`${API_URL}/api/upload`, {
        method: 'POST',
        body: formData,
        signal: controller.signal
      })
        .then(response => {
          clearTimeout(timeoutId);
          if (!response.ok) {
            return response.text().then(text => {
              throw new Error(`Network response was not ok: ${response.status} - ${text}`);
            });
          }
          return response.json();
        })
        .then(data => {
          progress = 100;
          isUploading = false;
          fetchQuestions();
          redraw();
        })
        .catch(error => {
          console.error('Upload error:', error.message);
          progress = 0;
          isUploading = false;
          clearTimeout(timeoutId);
          redraw();
        });
    });
  </script>
</body>
</html>